let data = [{
    "questionId": "1028",
    "titleSlug": "recover-a-tree-from-preorder-traversal",
    "translatedTitle": "从先序遍历还原二叉树",
    "translatedContent": [
        "我们从二叉树的根节点 root 开始进行深度优先搜索。",
        "",
        "在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。",
        "",
        "如果节点只有一个子节点，那么保证该子节点为左子节点。",
        "",
        "给出遍历输出 S，还原树并返回其根节点 root。",
        "",
        "示例 1: ",
        "输入: \"1-2--3--4-5--6--7\"",
        "输出: [1,2,5,3,4,6,7]",
        "",
        "示例 2: ",
        "输入: \"1-2--3---4-5--6---7\"",
        "输出: [1,2,5,3,null,6,null,4,null,7]",
        "",
        "示例 3: ",
        "输入: \"1-401--349---90--88\"",
        "输出: [1,401,null,349,88,90]",
        "",
        "提示: ",
        "原始树中的节点数介于 1 和 1000 之间。",
        "每个节点的值介于 1 和 10 ^ 9 之间。"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {string} S\r\n * @return {TreeNode}\r\n */\r\nvar recoverFromPreorder = function(S) {\r\n    \r\n};"
}, {
    "questionId": "1026",
    "titleSlug": "maximum-difference-between-node-and-ancestor",
    "translatedTitle": "节点与其祖先之间的最大差值",
    "translatedContent": [
        "给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。",
        "",
        "（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）",
        "",
        "示例: ",
        "输入: [8,3,10,1,6,null,14,null,null,4,7,13]",
        "输出: 7",
        "解释:  ",
        "我们有大量的节点与其祖先的差值，其中一些如下: ",
        "|8 - 3| = 5",
        "|3 - 7| = 4",
        "|8 - 1| = 7",
        "|10 - 13| = 3",
        "在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。",
        "",
        "提示: ",
        "树中的节点数在 2 到 5000 之间。",
        "每个节点的值介于 0 到 100000 之间。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxAncestorDiff = function(root) {\r\n    \r\n};"
}, {
    "questionId": "1027",
    "titleSlug": "longest-arithmetic-sequence",
    "translatedTitle": "最长等差数列",
    "translatedContent": [
        "给定一个整数数组 A，返回 A 中最长等差子序列的长度。",
        "",
        "回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。",
        "",
        "示例 1: ",
        "输入: [3,6,9,12]",
        "输出: 4",
        "解释:  ",
        "整个数组是公差为 3 的等差数列。",
        "",
        "示例 2: ",
        "输入: [9,4,7,2,10]",
        "输出: 3",
        "解释: ",
        "最长的等差子序列是 [4,7,10]。",
        "",
        "示例 3: ",
        "输入: [20,1,15,3,10,5,8]",
        "输出: 4",
        "解释: ",
        "最长的等差子序列是 [20,15,10,5]。",
        "",
        "提示: ",
        "2 <= A.length <= 2000",
        "0 <= A[i] <= 10000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {number}\r\n */\r\nvar longestArithSeqLength = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1025",
    "titleSlug": "divisor-game",
    "translatedTitle": "除数博弈",
    "translatedContent": [
        "爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。",
        "",
        "最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作: ",
        "",
        "选出任一 x，满足 0 < x < N 且 N % x == 0 。",
        "用 N - x 替换黑板上的数字 N 。",
        "",
        "如果玩家无法执行这些操作，就会输掉游戏。",
        "",
        "只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。",
        "",
        "示例 1: ",
        "输入: 2",
        "输出: true",
        "解释: 爱丽丝选择 1，鲍勃无法进行操作。",
        "",
        "示例 2: ",
        "输入: 3",
        "输出: false",
        "解释: 爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。",
        "",
        "提示: ",
        "1 <= N <= 1000"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {boolean}\r\n */\r\nvar divisorGame = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1024",
    "titleSlug": "video-stitching",
    "translatedTitle": "视频拼接",
    "translatedContent": [
        "你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。",
        "",
        "视频片段 clips[i] 都用区间进行表示: 开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。",
        "",
        "我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。",
        "",
        "示例 1: ",
        "输入: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10",
        "输出: 3",
        "解释: ",
        "我们选中 [0,2], [8,10], [1,9] 这三个片段。",
        "然后，按下面的方案重制比赛片段: ",
        "将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。",
        "现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。",
        "",
        "示例 2: ",
        "输入: clips = [[0,1],[1,2]], T = 5",
        "输出: -1",
        "解释: ",
        "我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。",
        "",
        "示例 3: ",
        "输入: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9",
        "输出: 3",
        "解释:  ",
        "我们选取片段 [0,4], [4,7] 和 [6,9] 。",
        "",
        "示例 4: ",
        "输入: clips = [[0,4],[2,8]], T = 5",
        "输出: 2",
        "解释: ",
        "注意，你可能录制超过比赛结束时间的视频。",
        "",
        "提示: ",
        "1 <= clips.length <= 100",
        "0 <= clips[i][0], clips[i][1] <= 100",
        "0 <= T <= 100"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[][]} clips\r\n * @param {number} T\r\n * @return {number}\r\n */\r\nvar videoStitching = function(clips, T) {\r\n    \r\n};"
}, {
    "questionId": "1023",
    "titleSlug": "camelcase-matching",
    "translatedTitle": "驼峰式匹配",
    "translatedContent": [
        "如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）",
        "",
        "给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。",
        "",
        "示例 1: ",
        "输入: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"",
        "输出: [true,false,true,true,false]",
        "示例: ",
        "\"FooBar\" 可以这样生成: \"F\" + \"oo\" + \"B\" + \"ar\"。",
        "\"FootBall\" 可以这样生成: \"F\" + \"oot\" + \"B\" + \"all\".",
        "\"FrameBuffer\" 可以这样生成: \"F\" + \"rame\" + \"B\" + \"uffer\".",
        "",
        "示例 2: ",
        "输入: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"",
        "输出: [true,false,true,false,false]",
        "解释: ",
        "\"FooBar\" 可以这样生成: \"Fo\" + \"o\" + \"Ba\" + \"r\".",
        "\"FootBall\" 可以这样生成: \"Fo\" + \"ot\" + \"Ba\" + \"ll\".",
        "",
        "示例 3: ",
        "输出: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"",
        "输入: [false,true,false,false,false]",
        "解释:  ",
        "\"FooBarTest\" 可以这样生成: \"Fo\" + \"o\" + \"Ba\" + \"r\" + \"T\" + \"est\".",
        "",
        "提示: ",
        "1 <= queries.length <= 100",
        "1 <= queries[i].length <= 100",
        "1 <= pattern.length <= 100",
        "所有字符串都仅由大写和小写英文字母组成。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {string[]} queries\r\n * @param {string} pattern\r\n * @return {boolean[]}\r\n */\r\nvar camelMatch = function(queries, pattern) {\r\n    \r\n};"
}, {
    "questionId": "1022",
    "titleSlug": "sum-of-root-to-leaf-binary-numbers",
    "translatedTitle": "从根到叶的二进制数之和",
    "translatedContent": [
        "给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。",
        "",
        "对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。",
        "",
        "以 10^9 + 7 为模，返回这些数字之和。",
        "",
        "示例: ",
        "输入: [1,0,1,0,1,0,1]",
        "输出: 22",
        "解释: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22",
        "",
        "提示: ",
        "树中的结点数介于 1 和 1000 之间。",
        "node.val 为 0 或 1 。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumRootToLeaf = function(root) {\r\n    \r\n};"
}, {
    "questionId": "1021",
    "titleSlug": "remove-outermost-parentheses",
    "translatedTitle": "删除最外层的括号",
    "translatedContent": [
        "有效括号字符串为空 (\"\")、\"(\" + A + \")\" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，\"\"，\"()\"，\"(())()\" 和 \"(()(()))\" 都是有效的括号字符串。",
        "",
        "如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。",
        "",
        "给出一个非空有效字符串 S，考虑将其进行原语化分解，使得: S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。",
        "",
        "对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。",
        "",
        "示例 1: ",
        "输入: \"(()())(())\"",
        "输出: \"()()()\"",
        "解释: ",
        "输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"，",
        "删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。",
        "",
        "示例 2: ",
        "输入: \"(()())(())(()(()))\"",
        "输出: \"()()()()(())\"",
        "解释: ",
        "输入字符串为 \"(()())(())(()(()))\"，原语化分解得到 \"(()())\" + \"(())\" + \"(()(()))\"，",
        "删除每隔部分中的最外层括号后得到 \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\"。",
        "",
        "示例 3: ",
        "输入: \"()()\"",
        "输出: \"\"",
        "解释: ",
        "输入字符串为 \"()()\"，原语化分解得到 \"()\" + \"()\"，",
        "删除每个部分中的最外层括号后得到 \"\" + \"\" = \"\"。",
        "",
        "提示: ",
        "S.length <= 10000",
        "S[i] 为 \"(\" 或 \")\"",
        "S 是一个有效括号字符串"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {string} S\r\n * @return {string}\r\n */\r\nvar removeOuterParentheses = function(S) {\r\n    \r\n};"
}, {
    "questionId": "1020",
    "titleSlug": "number-of-enclaves",
    "translatedTitle": "飞地的数量",
    "translatedContent": [
        "给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。",
        "",
        "移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。",
        "",
        "返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。",
        "",
        "示例 1: ",
        "输入: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]",
        "输出: 3",
        "解释:  ",
        "有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。",
        "",
        "示例 2: ",
        "输入: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]",
        "输出: 0",
        "解释: ",
        "所有 1 都在边界上或可以到达边界。",
        "",
        "提示: ",
        "1 <= A.length <= 500",
        "1 <= A[i].length <= 500",
        "0 <= A[i][j] <= 1",
        "所有行的大小都相同"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[][]} A\r\n * @return {number}\r\n */\r\nvar numEnclaves = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1019",
    "titleSlug": "next-greater-node-in-linked-list",
    "translatedTitle": "链表中的下一个更大节点",
    "translatedContent": [
        "给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为: node_1, node_2, node_3, ... 。",
        "",
        "每个节点都可能有下一个更大值（next larger value）: 对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。",
        "",
        "返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。",
        "",
        "注意: 在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。",
        "",
        "示例 1: ",
        "输入: [2,1,5]",
        "输出: [5,5,0]",
        "",
        "示例 2: ",
        "输入: [2,7,4,3,5]",
        "输出: [7,0,5,5,0]",
        "",
        "示例 3: ",
        "输入: [1,7,5,1,9,2,5,1]",
        "输出: [7,9,9,9,0,5,0,0]",
        "",
        "提示: ",
        "对于链表中的每个节点，1 <= node.val <= 10^9",
        "给定列表的长度在 [0, 10000] 范围内"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {number[]}\r\n */\r\nvar nextLargerNodes = function(head) {\r\n    \r\n};"
}, {
    "questionId": "1018",
    "titleSlug": "binary-prefix-divisible-by-5",
    "translatedTitle": "可被 5 整除的二进制前缀",
    "translatedContent": [
        "给定由若干 0 和 1 组成的数组 A。我们定义 N_i: 从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。",
        "",
        "返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。",
        "",
        "示例 1: ",
        "输入: [0,1,1]",
        "输出: [true,false,false]",
        "解释: ",
        "输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。",
        "",
        "示例 2: ",
        "输入: [1,1,1]",
        "输出: [false,false,false]",
        "",
        "示例 3: ",
        "输入: [0,1,1,1,1,1]",
        "输出: [true,false,false,false,true,false]",
        "",
        "示例 4: ",
        "输入: [1,1,1,0,1]",
        "输出: [false,false,false,false,false]",
        "",
        "提示: ",
        "1 <= A.length <= 30000",
        "A[i] 为 0 或 1"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {boolean[]}\r\n */\r\nvar prefixesDivBy5 = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1017",
    "titleSlug": "convert-to-base-2",
    "translatedTitle": "负二进制转换",
    "translatedContent": [
        "给出数字 N，返回由若干 \"0\" 和 \"1\"组成的字符串，该字符串为 N 的负二进制（base -2）表示。",
        "",
        "除非字符串就是 \"0\"，否则返回的字符串中不能含有前导零。",
        "",
        "示例 1: ",
        "输入: 2",
        "输出: \"110\"",
        "解释: (-2) ^ 2 + (-2) ^ 1 = 2",
        "",
        "示例 2: ",
        "输入: 3",
        "输出: \"111\"",
        "解释: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3",
        "",
        "示例 3: ",
        "输入: 4",
        "输出: \"100\"",
        "解释: (-2) ^ 2 = 4",
        "",
        "提示: ",
        "0 <= N <= 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {string}\r\n */\r\nvar baseNeg2 = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1016",
    "titleSlug": "binary-string-with-substrings-representing-1-to-n",
    "translatedTitle": "子串能表示从 1 到 N 数字的二进制串",
    "translatedContent": [
        "给定一个二进制字符串 S（一个仅由若干 &#39;0&#39; 和 &#39;1&#39; 构成的字符串）和一个正整数 N，如果对于从 1 到 N 的每个整数 X，其二进制表示都是 S 的子串，就返回 true，否则返回 false。",
        "",
        "示例 1: ",
        "输入: S = \"0110\", N = 3",
        "输出: true",
        "",
        "示例 2: ",
        "输入: S = \"0110\", N = 4",
        "输出: false",
        "",
        "提示: ",
        "1 <= S.length <= 1000",
        "1 <= N <= 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {string} S\r\n * @param {number} N\r\n * @return {boolean}\r\n */\r\nvar queryString = function(S, N) {\r\n    \r\n};"
}, {
    "questionId": "1015",
    "titleSlug": "smallest-integer-divisible-by-k",
    "translatedTitle": "可被 K 整除的最小整数",
    "translatedContent": [
        "给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。",
        "",
        "返回 N 的长度。如果不存在这样的 N，就返回 -1。",
        "",
        "示例 1: ",
        "输入: 1",
        "输出: 1",
        "解释: 最小的答案是 N = 1，其长度为 1。",
        "",
        "示例 2: ",
        "输入: 2",
        "输出: -1",
        "解释: 不存在可被 2 整除的正整数 N 。",
        "",
        "示例 3: ",
        "输入: 3",
        "输出: 3",
        "解释: 最小的答案是 N = 111，其长度为 3。",
        "",
        "提示: ",
        "1 <= K <= 10^5"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number} K\r\n * @return {number}\r\n */\r\nvar smallestRepunitDivByK = function(K) {\r\n    \r\n};"
}, {
    "questionId": "1014",
    "titleSlug": "best-sightseeing-pair",
    "translatedTitle": "最佳观光组合",
    "translatedContent": [
        "给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。",
        "",
        "一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）: 景点的评分之和减去它们两者之间的距离。",
        "",
        "返回一对观光景点能取得的最高分。",
        "",
        "示例: ",
        "输入: [8,1,5,2,6]",
        "输出: 11",
        "解释: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11",
        "",
        "提示: ",
        "2 <= A.length <= 50000",
        "1 <= A[i] <= 1000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {number}\r\n */\r\nvar maxScoreSightseeingPair = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1013",
    "titleSlug": "partition-array-into-three-parts-with-equal-sum",
    "translatedTitle": "将数组分成和相等的三个部分",
    "translatedContent": [
        "给定一个整数数组 A，只有我们可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。",
        "",
        "形式上，如果我们可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。",
        "",
        "示例 1: ",
        "输出: [0,2,1,-6,6,-7,9,1,2,0,1]",
        "输出: true",
        "解释: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
        "",
        "示例 2: ",
        "输入: [0,2,1,-6,6,7,9,-1,2,0,1]",
        "输出: false",
        "",
        "示例 3: ",
        "输入: [3,3,6,5,-2,2,5,1,-9,4]",
        "输出: true",
        "解释: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4",
        "",
        "提示: ",
        "3 <= A.length <= 50000",
        "-10000 <= A[i] <= 10000"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {boolean}\r\n */\r\nvar canThreePartsEqualSum = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1012",
    "titleSlug": "numbers-with-repeated-digits",
    "translatedTitle": "至少有 1 位重复的数字",
    "translatedContent": [
        "给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数。",
        "",
        "示例 1: ",
        "输入: 20",
        "输出: 1",
        "解释: 具有至少 1 位重复数字的正数（<= 20）只有 11 。",
        "",
        "示例 2: ",
        "输入: 100",
        "输出: 10",
        "解释: 具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。",
        "",
        "示例 3: ",
        "输入: 1000",
        "输出: 262",
        "",
        "提示: ",
        "1 <= N <= 10^9"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {number}\r\n */\r\nvar numDupDigitsAtMostN = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1011",
    "titleSlug": "capacity-to-ship-packages-within-d-days",
    "translatedTitle": "在 D 天内送达包裹的能力",
    "translatedContent": [
        "传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。",
        "",
        "传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。",
        "",
        "返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。",
        "",
        "示例 1: ",
        "输入: weights = [1,2,3,4,5,6,7,8,9,10], D = 5",
        "输出: 15",
        "解释: ",
        "船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示: ",
        "第 1 天: 1, 2, 3, 4, 5",
        "第 2 天: 6, 7",
        "第 3 天: 8",
        "第 4 天: 9",
        "第 5 天: 10",
        "",
        "请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 ",
        "",
        "示例 2: ",
        "输入: weights = [3,2,2,4,1,4], D = 3",
        "输出: 6",
        "解释: ",
        "船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示: ",
        "第 1 天: 3, 2",
        "第 2 天: 2, 4",
        "第 3 天: 1, 4",
        "",
        "示例 3: ",
        "输入: weights = [1,2,3,1,1], D = 4",
        "输出: 3",
        "解释: ",
        "第 1 天: 1",
        "第 2 天: 2",
        "第 3 天: 3",
        "第 4 天: 1, 1",
        "",
        "提示: ",
        "1 <= D <= weights.length <= 50000",
        "1 <= weights[i] <= 500"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[]} weights\r\n * @param {number} D\r\n * @return {number}\r\n */\r\nvar shipWithinDays = function(weights, D) {\r\n    \r\n};"
}, {
    "questionId": "1010",
    "titleSlug": "pairs-of-songs-with-total-durations-divisible-by-60",
    "translatedTitle": "总持续时间可被 60 整除的歌曲",
    "translatedContent": [
        "在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。",
        "",
        "返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。",
        "",
        "示例 1: ",
        "输入: [30,20,150,100,40]",
        "输出: 3",
        "解释: 这三对的总持续时间可被 60 整数: ",
        "(time[0] = 30, time[2] = 150): 总持续时间 180",
        "(time[1] = 20, time[3] = 100): 总持续时间 120",
        "(time[1] = 20, time[4] = 40): 总持续时间 60",
        "",
        "示例 2: ",
        "输入: [60,60,60]",
        "输出: 3",
        "解释: 所有三对的总持续时间都是 120，可以被 60 整数。",
        "",
        "提示: ",
        "1 <= time.length <= 60000",
        "1 <= time[i] <= 500"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number[]} time\r\n * @return {number}\r\n */\r\nvar numPairsDivisibleBy60 = function(time) {\r\n    \r\n};"
}, {
    "questionId": "1009",
    "titleSlug": "complement-of-base-10-integer",
    "translatedTitle": "十进制整数的反码",
    "translatedContent": [
        "每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 \"101\"，11 可以用二进制 \"1011\" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。",
        "",
        "二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 \"101\" 的二进制反码为 \"010\"。",
        "",
        "给定十进制数 N，返回其二进制表示的反码所对应的十进制整数。",
        "",
        "示例 1: ",
        "输入: 5",
        "输出: 2",
        "解释: 5 的二进制表示为 \"101\"，其二进制反码为 \"010\"，也就是十进制中的 2 。",
        "",
        "示例 2: ",
        "输入: 7",
        "输出: 0",
        "解释: 7 的二进制表示为 \"111\"，其二进制反码为 \"000\"，也就是十进制中的 0 。",
        "",
        "示例 3: ",
        "输入: 10",
        "输出: 5",
        "解释: 10 的二进制表示为 \"1010\"，其二进制反码为 \"0101\"，也就是十进制中的 5 。",
        "",
        "提示: ",
        "0 <= N < 10^9"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {number}\r\n */\r\nvar bitwiseComplement = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1008",
    "titleSlug": "construct-binary-search-tree-from-preorder-traversal",
    "translatedTitle": "先序遍历构造二叉树",
    "translatedContent": [
        "返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。",
        "",
        "(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）",
        "",
        "示例: ",
        "输入: [8,5,1,7,10,12]",
        "输出: [8,5,10,1,7,null,12]",
        "",
        "提示: ",
        "1 <= preorder.length <= 100",
        "先序 preorder 中的值是不同的。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} preorder\n * @return {TreeNode}\n */\nvar bstFromPreorder = function(preorder) {\n    \n};"
}, {
    "questionId": "1007",
    "titleSlug": "minimum-domino-rotations-for-equal-row",
    "translatedTitle": "行相等的最少多米诺旋转",
    "translatedContent": [
        "在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 &mdash;&mdash; 该平铺的每一半上都有一个数字。）",
        "",
        "我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。",
        "",
        "返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。",
        "",
        "如果无法做到，返回 -1.",
        "",
        "示例 1: ",
        "输入: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]",
        "输出: 2",
        "解释: ",
        "图一表示: 在我们旋转之前， A 和 B 给出的多米诺牌。",
        "如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。",
        "",
        "示例 2: ",
        "输入: A = [3,5,1,2,3], B = [3,6,3,3,4]",
        "输出: -1",
        "解释: ",
        "在这种情况下，不可能旋转多米诺牌使一行的值相等。",
        "",
        "提示: ",
        "1 <= A[i], B[i] <= 6",
        "2 <= A.length == B.length <= 20000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number}\n */\nvar minDominoRotations = function(A, B) {\n    \n};"
}, {
    "questionId": "1006",
    "titleSlug": "clumsy-factorial",
    "translatedTitle": "笨阶乘",
    "translatedContent": [
        "通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。",
        "",
        "相反，我们设计了一个笨阶乘 clumsy: 在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符: 乘法(*)，除法(/)，加法(+)和减法(-)。",
        "",
        "例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序: 我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。",
        "",
        "另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。",
        "",
        "实现上面定义的笨函数: 给定一个整数 N，它返回 N 的笨阶乘。",
        "",
        "示例 1: ",
        "输入: 4",
        "输出: 7",
        "解释: 7 = 4 * 3 / 2 + 1",
        "",
        "示例 2: ",
        "输入: 10",
        "输出: 12",
        "解释: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1",
        "",
        "提示: ",
        "1 <= N <= 10000",
        "-2^31 <= answer <= 2^31 - 1  （答案保证符合 32 位整数。）"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number} N\n * @return {number}\n */\nvar clumsy = function(N) {\n    \n};"
}, {
    "questionId": "1005",
    "titleSlug": "maximize-sum-of-array-after-k-negations",
    "translatedTitle": "K 次取反后最大化的数组和",
    "translatedContent": [
        "给定一个整数数组 A，我们只能用以下方法修改该数组: 我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）",
        "",
        "以这种方式修改数组后，返回数组可能的最大和。",
        "",
        "示例 1: ",
        "输入: A = [4,2,3], K = 1",
        "输出: 5",
        "解释: 选择索引 (1,) ，然后 A 变为 [4,-2,3]。",
        "",
        "示例 2: ",
        "输入: A = [3,-1,0,2], K = 3",
        "输出: 6",
        "解释: 选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。",
        "",
        "示例 3: ",
        "输入: A = [2,-3,-1,5,-4], K = 2",
        "输出: 13",
        "解释: 选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。",
        "",
        "提示: ",
        "1 <= A.length <= 10000",
        "1 <= K <= 10000",
        "-100 <= A[i] <= 100"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nvar largestSumAfterKNegations = function(A, K) {\n    \n};"
}, {
    "questionId": "1004",
    "titleSlug": "max-consecutive-ones-iii",
    "translatedTitle": "最大连续1的个数 III",
    "translatedContent": [
        "给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。",
        "",
        "返回仅包含 1 的最长（连续）子数组的长度。",
        "",
        "示例 1: ",
        "输入: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2",
        "输出: 6",
        "解释:  ",
        "[1,1,1,0,0,1,1,1,1,1,1]",
        "粗体数字从 0 翻转到 1，最长的子数组长度为 6。",
        "",
        "示例 2: ",
        "输入: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3",
        "输出: 10",
        "解释: ",
        "[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]",
        "粗体数字从 0 翻转到 1，最长的子数组长度为 10。",
        "",
        "提示: ",
        "1 <= A.length <= 20000",
        "0 <= K <= A.length",
        "A[i] 为 0 或 1"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nvar longestOnes = function(A, K) {\n    \n};"
}, {
    "questionId": "1003",
    "titleSlug": "check-if-word-is-valid-after-substitutions",
    "translatedTitle": "检查替换后的词是否有效",
    "translatedContent": [
        "给定有效字符串 \"abc\"。",
        "",
        "对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。（X 或 Y 可以为空。）那么，X + \"abc\" + Y 也同样是有效的。",
        "",
        "例如，如果 S = \"abc\"，则有效字符串的示例是: \"abc\"，\"aabcbc\"，\"abcabc\"，\"abcabcababcc\"。无效字符串的示例是: \"abccba\"，\"ab\"，\"cababc\"，\"bac\"。",
        "",
        "如果给定字符串 S 有效，则返回 true；否则，返回 false。",
        "",
        "示例 1: ",
        "输入: \"aabcbc\"",
        "输出: true",
        "解释: ",
        "从有效字符串 \"abc\" 开始。",
        "然后我们可以在 \"a\" 和 \"bc\" 之间插入另一个 \"abc\"，产生 \"a\" + \"abc\" + \"bc\"，即 \"aabcbc\"。",
        "",
        "示例 2: ",
        "输入: \"abcabcababcc\"",
        "输出: true",
        "解释: ",
        "\"abcabcabc\" 是有效的，它可以视作在原串后连续插入 \"abc\"。",
        "然后我们可以在最后一个字母之前插入 \"abc\"，产生 \"abcabcab\" + \"abc\" + \"c\"，即 \"abcabcababcc\"。",
        "",
        "示例 3: ",
        "输入: \"abccba\"",
        "输出: false",
        "",
        "示例 4: ",
        "输入: \"cababc\"",
        "输出: false",
        "",
        "提示: ",
        "1 <= S.length <= 20000",
        "S[i] 为 &#39;a&#39;、&#39;b&#39;、或 &#39;c&#39;"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {string} S\n * @return {boolean}\n */\nvar isValid = function(S) {\n    \n};"
}, {
    "questionId": "1002",
    "titleSlug": "find-common-characters",
    "translatedTitle": "查找常用字符",
    "translatedContent": [
        "给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。",
        "",
        "你可以按任意顺序返回答案。",
        "",
        "示例 1: ",
        "输入: [\"bella\",\"label\",\"roller\"]",
        "输出: [\"e\",\"l\",\"l\"]",
        "",
        "示例 2: ",
        "输入: [\"cool\",\"lock\",\"cook\"]",
        "输出: [\"c\",\"o\"]",
        "",
        "提示: ",
        "1 <= A.length <= 100",
        "1 <= A[i].length <= 100",
        "A[i][j] 是小写字母"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {string[]} A\n * @return {string[]}\n */\nvar commonChars = function(A) {\n    \n};"
}, {
    "questionId": "1001",
    "titleSlug": "grid-illumination",
    "translatedTitle": "网格照明",
    "translatedContent": [
        "在 N x N 的网格上，每个单元格 (x, y) 上都有一盏灯，其中 0 <= x < N 且 0 <= y < N 。",
        "",
        "最初，一定数量的灯是亮着的。lamps[i] 告诉我们亮着的第 i 盏灯的位置。每盏灯都照亮其所在 x 轴、y 轴和两条对角线上的每个正方形（类似于国际象棋中的皇后）。",
        "",
        "对于第 i 次查询 queries[i] = (x, y)，如果单元格 (x, y) 是被照亮的，则查询结果为 1，否则为 0 。",
        "",
        "在每个查询 (x, y) 之后 [按照查询的顺序]，我们关闭位于单元格 (x, y) 上或其相邻 8 个方向上（与单元格 (x, y) 共享一个角或边）的任何灯。",
        "",
        "返回答案数组 answer。每个值 answer[i] 应等于第 i 次查询 queries[i] 的结果。",
        "",
        "示例: ",
        "输入: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]",
        "输出: [1,0]",
        "解释:  ",
        "在执行第一次查询之前，我们位于 [0, 0] 和 [4, 4] 灯是亮着的。",
        "表示哪些单元格亮起的网格如下所示，其中 [0, 0] 位于左上角: ",
        "1 1 1 1 1",
        "1 1 0 0 1",
        "1 0 1 0 1",
        "1 0 0 1 1",
        "1 1 1 1 1",
        "然后，由于单元格 [1, 1] 亮着，第一次查询返回 1。在此查询后，位于 [0，0] 处的灯将关闭，网格现在如下所示: ",
        "1 0 0 0 1",
        "0 1 0 0 1",
        "0 0 1 0 1",
        "0 0 0 1 1",
        "1 1 1 1 1",
        "在执行第二次查询之前，我们只有 [4, 4] 处的灯亮着。现在，[1, 0] 处的查询返回 0，因为该单元格不再亮着。",
        "",
        "提示: ",
        "1 <= N <= 10^9",
        "0 <= lamps.length <= 20000",
        "0 <= queries.length <= 20000",
        "lamps[i].length == queries[i].length == 2"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number} N\n * @param {number[][]} lamps\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar gridIllumination = function(N, lamps, queries) {\n    \n};"
}, {
    "questionId": "1000",
    "titleSlug": "minimum-cost-to-merge-stones",
    "translatedTitle": "合并石头的最低成本",
    "translatedContent": [
        "有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。",
        "",
        "每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。",
        "",
        "找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。",
        "",
        "示例 1: ",
        "输入: stones = [3,2,4,1], K = 2",
        "输出: 20",
        "解释: ",
        "从 [3, 2, 4, 1] 开始。",
        "合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。",
        "合并 [4, 1]，成本为 5，剩下 [5, 5]。",
        "合并 [5, 5]，成本为 10，剩下 [10]。",
        "总成本 20，这是可能的最小值。",
        "",
        "示例 2: ",
        "输入: stones = [3,2,4,1], K = 3",
        "输出: -1",
        "解释: 任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.",
        "",
        "示例 3: ",
        "输入: stones = [3,5,1,2,6], K = 3",
        "输出: 25",
        "解释: ",
        "从 [3, 5, 1, 2, 6] 开始。",
        "合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。",
        "合并 [3, 8, 6]，成本为 17，剩下 [17]。",
        "总成本 25，这是可能的最小值。",
        "",
        "提示: ",
        "1 <= stones.length <= 30",
        "2 <= K <= 30",
        "1 <= stones[i] <= 100"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[]} stones\n * @param {number} K\n * @return {number}\n */\nvar mergeStones = function(stones, K) {\n    \n};"
}, {
    "questionId": "999",
    "titleSlug": "available-captures-for-rook",
    "translatedTitle": "车的可用捕获量",
    "translatedContent": [
        "在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 &ldquo;R&rdquo;，&ldquo;.&rdquo;，&ldquo;B&rdquo; 和 &ldquo;p&rdquo; 给出。大写字符表示白棋，小写字符表示黑棋。",
        "",
        "车按国际象棋中的规则移动: 它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。",
        "",
        "返回车能够在一次移动中捕获到的卒的数量。",
        "",
        "示例 1: ",
        "输入: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
        "输出: 3",
        "解释: ",
        "在本例中，车能够捕获所有的卒。",
        "",
        "示例 2: ",
        "输入: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
        "输出: 0",
        "解释: ",
        "象阻止了车捕获任何卒。",
        "",
        "示例 3: ",
        "输入: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
        "输出: 3",
        "解释:  ",
        "车可以捕获位置 b5，d6 和 f5 的卒。",
        "",
        "提示: ",
        "board.length == board[i].length == 8",
        "board[i][j] 可以是 &#39;R&#39;，&#39;.&#39;，&#39;B&#39; 或 &#39;p&#39;",
        "只有一个格子上存在 board[i][j] == &#39;R&#39;"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {character[][]} board\n * @return {number}\n */\nvar numRookCaptures = function(board) {\n    \n};"
}, {
    "questionId": "998",
    "titleSlug": "maximum-binary-tree-ii",
    "translatedTitle": "最大二叉树 II",
    "translatedContent": [
        "最大树定义: 一个树，其中每个节点的值都大于其子树中的任何其他值。",
        "",
        "给出最大树的根节点 root。",
        "",
        "就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的: ",
        "",
        "如果 A 为空，返回 null",
        "否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root",
        "root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]])",
        "root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]])",
        "返回 root",
        "",
        "请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).",
        "",
        "假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。",
        "",
        "返回 Construct(B)。",
        "",
        "示例 1: ",
        "输入: root = [4,1,3,null,null,2], val = 5",
        "输出: [5,4,null,1,3,null,null,2]",
        "解释: A = [1,4,2,3], B = [1,4,2,3,5]",
        "",
        "示例 2: ",
        "输入: root = [5,2,4,null,1], val = 3",
        "输出: [5,2,4,null,1,null,3]",
        "解释: A = [2,1,5,4], B = [2,1,5,4,3]",
        "",
        "示例 3: ",
        "输入: root = [5,2,3,null,1], val = 4",
        "输出: [5,2,4,null,1,3]",
        "解释: A = [2,1,5,3], B = [2,1,5,3,4]",
        "",
        "提示: ",
        "1 <= B.length <= 100"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar insertIntoMaxTree = function(root, val) {\n    \n};"
}, {
    "questionId": "997",
    "titleSlug": "find-the-town-judge",
    "translatedTitle": "找到小镇的法官",
    "translatedContent": [
        "在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。",
        "",
        "如果小镇的法官真的存在，那么: ",
        "",
        "小镇的法官不相信任何人。",
        "每个人（除了小镇法官外）都信任小镇的法官。",
        "只有一个人同时满足属性 1 和属性 2 。",
        "",
        "给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。",
        "",
        "如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。",
        "",
        "示例 1: ",
        "输入: N = 2, trust = [[1,2]]",
        "输出: 2",
        "",
        "示例 2: ",
        "输入: N = 3, trust = [[1,3],[2,3]]",
        "输出: 3",
        "",
        "示例 3: ",
        "输入: N = 3, trust = [[1,3],[2,3],[3,1]]",
        "输出: -1",
        "",
        "示例 4: ",
        "输入: N = 3, trust = [[1,2],[2,3]]",
        "输出: -1",
        "",
        "示例 5: ",
        "输入: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]",
        "输出: 3",
        "",
        "提示: ",
        "1 <= N <= 1000",
        "trust.length <= 10000",
        "trust[i] 是完全不同的",
        "trust[i][0] != trust[i][1]",
        "1 <= trust[i][0], trust[i][1] <= N"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number} N\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(N, trust) {\n    \n};"
}, {
    "questionId": "996",
    "titleSlug": "number-of-squareful-arrays",
    "translatedTitle": "正方形数组的数目",
    "translatedContent": [
        "给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。",
        "",
        "返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。",
        "",
        "示例 1: ",
        "输入: [1,17,8]",
        "输出: 2",
        "解释: ",
        "[1,8,17] 和 [17,8,1] 都是有效的排列。",
        "",
        "示例 2: ",
        "输入: [2,2,2]",
        "输出: 1",
        "",
        "提示: ",
        "1 <= A.length <= 12",
        "0 <= A[i] <= 1e9"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number}\n */\nvar numSquarefulPerms = function(A) {\n    \n};"
}, {
    "questionId": "995",
    "titleSlug": "minimum-number-of-k-consecutive-bit-flips",
    "translatedTitle": "K 连续位的最小翻转次数",
    "translatedContent": [
        "在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。",
        "",
        "返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。",
        "",
        "示例 1: ",
        "输入: A = [0,1,0], K = 1",
        "输出: 2",
        "解释: 先翻转 A[0]，然后翻转 A[2]。",
        "",
        "示例 2: ",
        "输入: A = [1,1,0], K = 2",
        "输出: -1",
        "解释: 无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。",
        "",
        "示例 3: ",
        "输入: A = [0,0,0,1,0,1,1,0], K = 3",
        "输出: 3",
        "解释: ",
        "翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]",
        "翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]",
        "翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]",
        "",
        "提示: ",
        "1 <= A.length <= 30000",
        "1 <= K <= A.length"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nvar minKBitFlips = function(A, K) {\n    \n};"
}, {
    "questionId": "994",
    "titleSlug": "rotting-oranges",
    "translatedTitle": "腐烂的橘子",
    "translatedContent": [
        "在给定的网格中，每个单元格可以有以下三个值之一: ",
        "",
        "值 0 代表空单元格；",
        "值 1 代表新鲜橘子；",
        "值 2 代表腐烂的橘子。",
        "",
        "每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。",
        "",
        "返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。",
        "",
        "示例 1: ",
        "输入: [[2,1,1],[1,1,0],[0,1,1]]",
        "输出: 4",
        "",
        "示例 2: ",
        "输入: [[2,1,1],[0,1,1],[1,0,1]]",
        "输出: -1",
        "解释: 左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。",
        "",
        "示例 3: ",
        "输入: [[0,2]]",
        "输出: 0",
        "解释: 因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。",
        "",
        "提示: ",
        "1 <= grid.length <= 10",
        "1 <= grid[0].length <= 10",
        "grid[i][j] 仅为 0、1 或 2"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar orangesRotting = function(grid) {\n    \n};"
}, {
    "questionId": "993",
    "titleSlug": "cousins-in-binary-tree",
    "translatedTitle": "二叉树的堂兄弟节点",
    "translatedContent": [
        "在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。",
        "",
        "如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。",
        "",
        "我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。",
        "",
        "只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。",
        "",
        "示例 1: ",
        "输入: root = [1,2,3,4], x = 4, y = 3",
        "输出: false",
        "",
        "示例 2: ",
        "输入: root = [1,2,3,null,4,null,5], x = 5, y = 4",
        "输出: true",
        "",
        "示例 3: ",
        "输入: root = [1,2,3,null,4], x = 2, y = 3",
        "输出: false",
        "",
        "提示: ",
        "二叉树的节点数介于 2 到 100 之间。",
        "每个节点的值都是唯一的、范围为 1 到 100 的整数。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nvar isCousins = function(root, x, y) {\n    \n};"
}, {
    "questionId": "992",
    "titleSlug": "subarrays-with-k-different-integers",
    "translatedTitle": "K 个不同整数的子数组",
    "translatedContent": [
        "给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。",
        "",
        "（例如，[1,2,3,1,2] 中有 3 个不同的整数: 1，2，以及 3。）",
        "",
        "返回 A 中好子数组的数目。",
        "",
        "示例 1: ",
        "输出: A = [1,2,1,2,3], K = 2",
        "输入: 7",
        "解释: 恰好由 2 个不同整数组成的子数组: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].",
        "",
        "示例 2: ",
        "输入: A = [1,2,1,3,4], K = 3",
        "输出: 3",
        "解释: 恰好由 3 个不同整数组成的子数组: [1,2,1,3], [2,1,3], [1,3,4].",
        "",
        "提示: ",
        "1 <= A.length <= 20000",
        "1 <= A[i] <= A.length",
        "1 <= K <= A.length"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nvar subarraysWithKDistinct = function(A, K) {\n    \n};"
}, {
    "questionId": "991",
    "titleSlug": "broken-calculator",
    "translatedTitle": "坏了的计算器",
    "translatedContent": [
        "在显示着数字的坏计算器上，我们可以执行以下两种操作: ",
        "",
        "双倍（Double）: 将显示屏上的数字乘 2；",
        "递减（Decrement）: 将显示屏上的数字减 1 。",
        "",
        "最初，计算器显示数字 X。",
        "",
        "返回显示数字 Y 所需的最小操作数。",
        "",
        "示例 1: ",
        "输入: X = 2, Y = 3",
        "输出: 2",
        "解释: 先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.",
        "",
        "示例 2: ",
        "输入: X = 5, Y = 8",
        "输出: 2",
        "解释: 先递减，再双倍 {5 -> 4 -> 8}.",
        "",
        "示例 3: ",
        "输入: X = 3, Y = 10",
        "输出: 3",
        "解释: 先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.",
        "",
        "示例 4: ",
        "输入: X = 1024, Y = 1",
        "输出: 1023",
        "解释: 执行递减运算 1023 次",
        "",
        "提示: ",
        "1 <= X <= 10^9",
        "1 <= Y <= 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number} X\n * @param {number} Y\n * @return {number}\n */\nvar brokenCalc = function(X, Y) {\n    \n};"
}, {
    "questionId": "990",
    "titleSlug": "satisfiability-of-equality-equations",
    "translatedTitle": "等式方程的可满足性",
    "translatedContent": [
        "给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一: \"a==b\" 或 \"a!=b\"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。",
        "",
        "只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 ",
        "",
        "示例 1: ",
        "输入: [\"a==b\",\"b!=a\"]",
        "输出: false",
        "解释: 如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。",
        "",
        "示例 2: ",
        "输出: [\"b==a\",\"a==b\"]",
        "输入: true",
        "解释: 我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。",
        "",
        "示例 3: ",
        "输入: [\"a==b\",\"b==c\",\"a==c\"]",
        "输出: true",
        "",
        "示例 4: ",
        "输入: [\"a==b\",\"b!=c\",\"c==a\"]",
        "输出: false",
        "",
        "示例 5: ",
        "输入: [\"c==c\",\"b==d\",\"x!=z\"]",
        "输出: true",
        "",
        "提示: ",
        "1 <= equations.length <= 500",
        "equations[i].length == 4",
        "equations[i][0] 和 equations[i][3] 是小写字母",
        "equations[i][1] 要么是 &#39;=&#39;，要么是 &#39;!&#39;",
        "equations[i][2] 是 &#39;=&#39;"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {string[]} equations\n * @return {boolean}\n */\nvar equationsPossible = function(equations) {\n    \n};"
}, {
    "questionId": "989",
    "titleSlug": "add-to-array-form-of-integer",
    "translatedTitle": "数组形式的整数加法",
    "translatedContent": [
        "对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。",
        "",
        "给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。",
        "",
        "示例 1: ",
        "输入: A = [1,2,0,0], K = 34",
        "输出: [1,2,3,4]",
        "解释: 1200 + 34 = 1234",
        "",
        "解释 2: ",
        "",
        "输入: A = [2,7,4], K = 181",
        "输出: [4,5,5]",
        "解释: 274 + 181 = 455",
        "",
        "示例 3: ",
        "输入: A = [2,1,5], K = 806",
        "输出: [1,0,2,1]",
        "解释: 215 + 806 = 1021",
        "",
        "示例 4: ",
        "输入: A = [9,9,9,9,9,9,9,9,9,9], K = 1",
        "输出: [1,0,0,0,0,0,0,0,0,0,0]",
        "解释: 9999999999 + 1 = 10000000000",
        "",
        "提示: ",
        "1 <= A.length <= 10000",
        "0 <= A[i] <= 9",
        "0 <= K <= 10000",
        "如果 A.length > 1，那么 A[0] != 0"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function(A, K) {\n    \n};"
}, {
    "questionId": "988",
    "titleSlug": "smallest-string-starting-from-leaf",
    "translatedTitle": "从叶结点开始的最小字符串",
    "translatedContent": [
        "给定一颗根结点为 root 的二叉树，书中的每个结点都有一个从 0 到 25 的值，分别代表字母 &#39;a&#39; 到 &#39;z&#39;: 值 0 代表 &#39;a&#39;，值 1 代表 &#39;b&#39;，依此类推。",
        "",
        "找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。",
        "",
        "（小贴士: 字符串中任何较短的前缀在字典序上都是较小的: 例如，在字典序上 \"ab\" 比 \"aba\" 要小。叶结点是指没有子结点的结点。）",
        "",
        "示例 1: ",
        "输入: [0,1,2,3,4,3,4]",
        "输出: \"dba\"",
        "",
        "示例 2: ",
        "输入: [25,1,3,1,3,0,2]",
        "输出: \"adz\"",
        "",
        "示例 3: ",
        "输入: [2,2,1,null,1,0,null,0]",
        "输出: \"abc\"",
        "",
        "提示: ",
        "给定树的结点数介于 1 和 8500 之间。",
        "树中的每个结点都有一个介于 0 和 25 之间的值。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string}\n */\nvar smallestFromLeaf = function(root) {\n    \n};"
}, {
    "questionId": "987",
    "titleSlug": "vertical-order-traversal-of-a-binary-tree",
    "translatedTitle": "二叉树的垂序遍历",
    "translatedContent": [
        "给定二叉树，按垂序遍历返回其结点值。",
        "",
        "对位于 (X, Y) 的每个结点而言，其左右子结点分别位于 (X-1, Y-1) 和 (X+1, Y-1)。",
        "",
        "把一条垂线从 X = -infinity 移动到 X = +infinity ，每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（ Y 坐标递减）。",
        "",
        "如果两个结点位置相同，则首先报告的结点值较小。",
        "",
        "按 X 坐标顺序返回非空报告的列表。每个报告都有一个结点值列表。",
        "",
        "示例 1: ",
        "输入: [3,9,20,null,null,15,7]",
        "输出: [[9],[3,15],[20],[7]]",
        "解释:  ",
        "在不丧失其普遍性的情况下，我们可以假设根结点位于 (0, 0): ",
        "然后，值为 9 的结点出现在 (-1, -1)；",
        "值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；",
        "值为 20 的结点出现在 (1, -1)；",
        "值为 7 的结点出现在 (2, -2)。",
        "",
        "示例 2: ",
        "输入: [1,2,3,4,5,6,7]",
        "输出: [[4],[2],[1,5,6],[3],[7]]",
        "解释: ",
        "根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。",
        "然而，在报告 \"[1,5,6]\" 中，结点值 5 排在前面，因为 5 小于 6。",
        "",
        "提示: ",
        "树的结点数介于 1 和 1000 之间。",
        "每个结点值介于 0 和 1000 之间。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    \n};"
}, {
    "questionId": "986",
    "titleSlug": "interval-list-intersections",
    "translatedTitle": "区间列表的交集",
    "translatedContent": [
        "给定两个由一些闭区间组成的列表，每个区间列表都是成对不相交的，并且已经排序。",
        "",
        "返回这两个区间列表的交集。",
        "",
        "（形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）",
        "",
        "示例: ",
        "输入: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]",
        "输出: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]",
        "注意: 输入和所需的输出都是区间对象组成的列表，而不是数组或列表。",
        "",
        "提示: ",
        "0 <= A.length < 1000",
        "0 <= B.length < 1000",
        "0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */\n/**\n * @param {Interval[]} A\n * @param {Interval[]} B\n * @return {Interval[]}\n */\nvar intervalIntersection = function(A, B) {\n    \n};"
}, {
    "questionId": "985",
    "titleSlug": "sum-of-even-numbers-after-queries",
    "translatedTitle": "查询后的偶数和",
    "translatedContent": [
        "给出一个整数数组 A 和一个查询数组 queries。",
        "",
        "对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。",
        "",
        "（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）",
        "",
        "返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。",
        "",
        "示例: ",
        "输入: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]",
        "输出: [8,6,2,4]",
        "解释: ",
        "开始时，数组为 [1,2,3,4]。",
        "将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。",
        "将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。",
        "将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。",
        "将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。",
        "",
        "提示: ",
        "1 <= A.length <= 10000",
        "-10000 <= A[i] <= 10000",
        "1 <= queries.length <= 10000",
        "-10000 <= queries[i][0] <= 10000",
        "0 <= queries[i][1] < A.length"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar sumEvenAfterQueries = function(A, queries) {\n    \n};"
}, {
    "questionId": "984",
    "titleSlug": "string-without-aaa-or-bbb",
    "translatedTitle": "不含 AAA 或 BBB 的字符串",
    "translatedContent": [
        "给定两个整数 A 和 B，返回任意字符串 S，要求满足: ",
        "",
        "S 的长度为 A + B，且正好包含 A 个 &#39;a&#39; 字母与 B 个 &#39;b&#39; 字母；",
        "子串 &#39;aaa&#39; 没有出现在 S 中；",
        "子串 &#39;bbb&#39; 没有出现在 S 中。",
        "",
        "示例 1: ",
        "输入: A = 1, B = 2",
        "输出: \"abb\"",
        "解释: \"abb\", \"bab\" 和 \"bba\" 都是正确答案。",
        "",
        "示例 2: ",
        "输入: A = 4, B = 1",
        "输出: \"aabaa\"",
        "",
        "提示: ",
        "0 <= A <= 100",
        "0 <= B <= 100",
        "对于给定的 A 和 B，保证存在满足要求的 S。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number} A\n * @param {number} B\n * @return {string}\n */\nvar strWithout3a3b = function(A, B) {\n    \n};"
}, {
    "questionId": "983",
    "titleSlug": "minimum-cost-for-tickets",
    "translatedTitle": "最低票价",
    "translatedContent": [
        "在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。",
        "",
        "火车票有三种不同的销售方式: ",
        "",
        "一张为期一天的通行证售价为 costs[0] 美元；",
        "一张为期七天的通行证售价为 costs[1] 美元；",
        "一张为期三十天的通行证售价为 costs[2] 美元。",
        "",
        "通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天: 第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。",
        "",
        "返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。",
        "",
        "示例 1: ",
        "输入: days = [1,4,6,7,8,20], costs = [2,7,15]",
        "输出: 11",
        "解释:  ",
        "例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划: ",
        "在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。",
        "在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。",
        "在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。",
        "你总共花了 $11，并完成了你计划的每一天旅行。",
        "",
        "示例 2: ",
        "输入: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]",
        "输出: 17",
        "解释: ",
        "例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划:  ",
        "在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。",
        "在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 ",
        "你总共花了 $17，并完成了你计划的每一天旅行。",
        "",
        "提示: ",
        "1 <= days.length <= 365",
        "1 <= days[i] <= 365",
        "days 按顺序严格递增",
        "costs.length == 3",
        "1 <= costs[i] <= 1000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} days\n * @param {number[]} costs\n * @return {number}\n */\nvar mincostTickets = function(days, costs) {\n    \n};"
}, {
    "questionId": "982",
    "titleSlug": "triples-with-bitwise-and-equal-to-zero",
    "translatedTitle": "按位与为零的三元组",
    "translatedContent": [
        "给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得: ",
        "",
        "0 <= i < A.length",
        "0 <= j < A.length",
        "0 <= k < A.length",
        "A[i] &amp; A[j] &amp; A[k] == 0，其中 &amp; 表示按位与（AND）操作符。",
        "",
        "示例: ",
        "输入: [2,1,3]",
        "输出: 12",
        "解释: 我们可以选出如下 i, j, k 三元组: ",
        "(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1",
        "(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2",
        "(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1",
        "(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3",
        "(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1",
        "(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2",
        "(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1",
        "(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3",
        "(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2",
        "(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2",
        "(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1",
        "(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2",
        "",
        "提示: ",
        "1 <= A.length <= 1000",
        "0 <= A[i] < 2^16"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number}\n */\nvar countTriplets = function(A) {\n    \n};"
}, {
    "questionId": "981",
    "titleSlug": "time-based-key-value-store",
    "translatedTitle": "基于时间的键值存储",
    "translatedContent": [
        "创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作: ",
        "",
        "1. set(string key, string value, int timestamp)",
        "",
        "存储键 key、值 value，以及给定的时间戳 timestamp。",
        "",
        "2. get(string key, int timestamp)",
        "",
        "返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev <= timestamp。",
        "如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。",
        "如果没有值，则返回空字符串（\"\"）。",
        "",
        "示例 1: ",
        "输入: inputs = [\"TimeMap\",\"set\",\"get\",\"get\",\"set\",\"get\",\"get\"], inputs = [[],[\"foo\",\"bar\",1],[\"foo\",1],[\"foo\",3],[\"foo\",\"bar2\",4],[\"foo\",4],[\"foo\",5]]",
        "输出: [null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]",
        "解释:   ",
        "TimeMap kv;   ",
        "kv.set(\"foo\", \"bar\", 1); // 存储键 \"foo\" 和值 \"bar\" 以及时间戳 timestamp = 1   ",
        "kv.get(\"foo\", 1);  // 输出 \"bar\"   ",
        "kv.get(\"foo\", 3); // 输出 \"bar\" 因为在时间戳 3 和时间戳 2 处没有对应 \"foo\" 的值，所以唯一的值位于时间戳 1 处（即 \"bar\"）   ",
        "kv.set(\"foo\", \"bar2\", 4);   ",
        "kv.get(\"foo\", 4); // 输出 \"bar2\"   ",
        "kv.get(\"foo\", 5); // 输出 \"bar2\"   ",
        "",
        "示例 2: ",
        "输入: inputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"], inputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]",
        "输出: [null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"]",
        "",
        "提示: ",
        "所有的键/值字符串都是小写的。",
        "所有的键/值字符串长度都在 [1, 100] 范围内。",
        "所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。",
        "1 <= timestamp <= 10^7",
        "TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Initialize your data structure here.\n */\nvar TimeMap = function() {\n    \n};\n\n/** \n * @param {string} key \n * @param {string} value \n * @param {number} timestamp\n * @return {void}\n */\nTimeMap.prototype.set = function(key, value, timestamp) {\n    \n};\n\n/** \n * @param {string} key \n * @param {number} timestamp\n * @return {string}\n */\nTimeMap.prototype.get = function(key, timestamp) {\n    \n};\n\n/** \n * Your TimeMap object will be instantiated and called as such:\n * var obj = new TimeMap()\n * obj.set(key,value,timestamp)\n * var param_2 = obj.get(key,timestamp)\n */"
}, {
    "questionId": "980",
    "titleSlug": "unique-paths-iii",
    "translatedTitle": "不同路径 III",
    "translatedContent": [
        "在二维网格 grid 上，有 4 种类型的方格: ",
        "",
        "1 表示起始方格。且只有一个起始方格。",
        "2 表示结束方格，且只有一个结束方格。",
        "0 表示我们可以走过的空方格。",
        "-1 表示我们无法跨越的障碍。",
        "",
        "返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。",
        "",
        "示例 1: ",
        "输入: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]",
        "输出: 2",
        "解释: 我们有以下两条路径: ",
        "1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)",
        "2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)",
        "",
        "示例 2: ",
        "输入: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]",
        "输出: 4",
        "解释: 我们有以下四条路径:  ",
        "1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)",
        "2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)",
        "3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)",
        "4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)",
        "",
        "示例 3: ",
        "输入: [[0,1],[2,0]]",
        "输出: 0",
        "解释: ",
        "没有一条路能完全穿过每一个空的方格一次。",
        "请注意，起始和结束方格可以位于网格中的任意位置。",
        "",
        "提示: ",
        "1 <= grid.length * grid[0].length <= 20"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar uniquePathsIII = function(grid) {\n    \n};"
}, {
    "questionId": "979",
    "titleSlug": "distribute-coins-in-binary-tree",
    "translatedTitle": "在二叉树中分配硬币",
    "translatedContent": [
        "给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。",
        "",
        "在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。",
        "",
        "返回使每个结点上只有一枚硬币所需的移动次数。",
        "",
        "示例 1: ",
        "输入: [3,0,0]",
        "输出: 2",
        "解释: 从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。",
        "",
        "示例 2: ",
        "输入: [0,3,0]",
        "输出: 3",
        "解释: 从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。",
        "",
        "示例 3: ",
        "输入: [1,0,2]",
        "输出: 2",
        "",
        "示例 4: ",
        "输入: [1,0,0,null,3]",
        "输出: 4",
        "",
        "提示: ",
        "1<= N <= 100",
        "0 <= node.val <= N"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar distributeCoins = function(root) {\n    \n};"
}, {
    "questionId": "978",
    "titleSlug": "longest-turbulent-subarray",
    "translatedTitle": "最长湍流子数组",
    "translatedContent": [
        "当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组: ",
        "",
        "若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；",
        "或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。",
        "",
        "也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。",
        "",
        "返回 A 的最大湍流子数组的长度。",
        "",
        "示例 1: ",
        "输入: [9,4,2,10,7,8,8,1,9]",
        "输出: 5",
        "解释: (A[1] > A[2] < A[3] > A[4] < A[5])",
        "",
        "示例 2: ",
        "输入: [4,8,12,16]",
        "输出: 2",
        "",
        "示例 3: ",
        "输入: [100]",
        "输出: 1",
        "",
        "提示: ",
        "1 <= A.length <= 40000",
        "0 <= A[i] <= 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number}\n */\nvar maxTurbulenceSize = function(A) {\n    \n};"
}, {
    "questionId": "977",
    "titleSlug": "squares-of-a-sorted-array",
    "translatedTitle": "有序数组的平方",
    "translatedContent": [
        "给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。",
        "",
        "示例 1: ",
        "输入: [-4,-1,0,3,10]",
        "输出: [0,1,9,16,100]",
        "",
        "示例 2: ",
        "输入: [-7,-3,2,3,11]",
        "输出: [4,9,9,49,121]",
        "",
        "提示: ",
        "1 <= A.length <= 10000",
        "-10000 <= A[i] <= 10000",
        "A 已按非递减顺序排序。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nvar sortedSquares = function(A) {\n    \n};"
}, {
    "questionId": "976",
    "titleSlug": "largest-perimeter-triangle",
    "translatedTitle": "三角形的最大周长",
    "translatedContent": [
        "给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。",
        "",
        "如果不能形成任何面积不为零的三角形，返回 0。",
        "",
        "示例 1: ",
        "输入: [2,1,2]",
        "输出: 5",
        "",
        "示例 2: ",
        "输入: [1,2,1]",
        "输出: 0",
        "",
        "示例 3: ",
        "输入: [3,2,3,4]",
        "输出: 10",
        "",
        "示例 4: ",
        "输入: [3,6,2,3]",
        "输出: 8",
        "",
        "提示: ",
        "3 <= A.length <= 10000",
        "1 <= A[i] <= 10^6"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number}\n */\nvar largestPerimeter = function(A) {\n    \n};"
}, {
    "questionId": "975",
    "titleSlug": "odd-even-jump",
    "translatedTitle": "奇偶跳",
    "translatedContent": [
        "给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。",
        "",
        "你可以按以下方式从索引 i 向后跳转到索引 j（其中 i < j）: ",
        "",
        "在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。",
        "在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，使得 A[i] => A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。",
        "（对于某些索引 i，可能无法进行合乎要求的跳跃。）",
        "",
        "如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。",
        "",
        "返回好的起始索引的数量。",
        "",
        "示例 1: ",
        "输入: [10,13,12,14,15]",
        "输出: 2",
        "解释:  ",
        "从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。",
        "从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。",
        "从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。",
        "从起始索引 i = 4 出发，我们已经到达数组末尾。",
        "总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。",
        "",
        "示例 2: ",
        "输入: [2,3,1,1,4]",
        "输出: 3",
        "解释: ",
        "从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3: ",
        "",
        "在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。",
        "",
        "在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。",
        "",
        "在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。",
        "",
        "我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。",
        "",
        "类似地，我们可以推断: ",
        "从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。",
        "从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。",
        "从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。",
        "从起始索引 i = 4 出发，我们已经到达数组末尾。",
        "总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。",
        "",
        "示例 3: ",
        "输入: [5,1,3,4,2]",
        "输出: 3",
        "解释:  ",
        "我们可以从起始索引 1，2，4 出发到达数组末尾。",
        "",
        "提示: ",
        "1 <= A.length <= 20000",
        "0 <= A[i] < 100000"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number}\n */\nvar oddEvenJumps = function(A) {\n    \n};"
}, {
    "questionId": "974",
    "titleSlug": "subarray-sums-divisible-by-k",
    "translatedTitle": "和可被 K 整除的子数组",
    "translatedContent": [
        "给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。",
        "",
        "示例: ",
        "输入: A = [4,5,0,-2,-3,1], K = 5",
        "输出: 7",
        "解释: ",
        "有 7 个子数组满足其元素之和可被 K = 5 整除: ",
        "[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]",
        "",
        "提示: ",
        "1 <= A.length <= 30000",
        "-10000 <= A[i] <= 10000",
        "2 <= K <= 10000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nvar subarraysDivByK = function(A, K) {\n    \n};"
}, {
    "questionId": "971",
    "titleSlug": "flip-binary-tree-to-match-preorder-traversal",
    "translatedTitle": "翻转二叉树以匹配先序遍历",
    "translatedContent": [
        "给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, ..., N} 中的值。",
        "",
        "通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。",
        "",
        "考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。",
        "",
        "（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）",
        "",
        "我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。 ",
        "",
        "如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。",
        "",
        "如果不能，则返回列表 [-1]。",
        "",
        "示例 1: ",
        "输入: root = [1,2], voyage = [2,1]",
        "输出: [-1]",
        "",
        "示例 2: ",
        "输入: root = [1,2,3], voyage = [1,3,2]",
        "输出: [1]",
        "",
        "示例 3: ",
        "输入: root = [1,2,3], voyage = [1,2,3]",
        "输出: []",
        "",
        "提示: ",
        "1 <= N <= 100"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number[]} voyage\n * @return {number[]}\n */\nvar flipMatchVoyage = function(root, voyage) {\n    \n};"
}, {
    "questionId": "970",
    "titleSlug": "powerful-integers",
    "translatedTitle": "强整数",
    "translatedContent": [
        "给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个强整数。",
        "",
        "返回值小于或等于 bound 的所有强整数组成的列表。",
        "",
        "你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。",
        "",
        "示例 1: ",
        "输入: x = 2, y = 3, bound = 10",
        "输出: [2,3,4,5,7,9,10]",
        "解释:  ",
        "2 = 2^0 + 3^0",
        "3 = 2^1 + 3^0",
        "4 = 2^0 + 3^1",
        "5 = 2^1 + 3^1",
        "7 = 2^2 + 3^1",
        "9 = 2^3 + 3^0",
        "10 = 2^0 + 3^2",
        "",
        "示例 2: ",
        "输入: x = 3, y = 5, bound = 15",
        "输出: [2,4,6,8,10,14]",
        "",
        "提示: ",
        "1 <= x <= 100",
        "1 <= y <= 100",
        "0 <= bound <= 10^6"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} bound\n * @return {number[]}\n */\nvar powerfulIntegers = function(x, y, bound) {\n    \n};"
}, {
    "questionId": "969",
    "titleSlug": "pancake-sorting",
    "translatedTitle": "煎饼排序",
    "translatedContent": [
        "给定数组 A，我们可以对其进行煎饼翻转: 我们选择一些正整数 k <= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。",
        "",
        "返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。",
        "",
        "示例 1: ",
        "输入: [3,2,4,1]",
        "输出: [4,2,4,3]",
        "解释: ",
        "我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。",
        "初始状态 A = [3, 2, 4, 1]",
        "第一次翻转后 (k=4): A = [1, 4, 2, 3]",
        "第二次翻转后 (k=2): A = [4, 1, 2, 3]",
        "第三次翻转后 (k=4): A = [3, 2, 1, 4]",
        "第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 ",
        "",
        "示例 2: ",
        "输入: [1,2,3]",
        "输出: []",
        "解释: ",
        "输入已经排序，因此不需要翻转任何内容。",
        "请注意，其他可能的答案，如[3，3]，也将被接受。",
        "",
        "提示: ",
        "1 <= A.length <= 100",
        "A[i] 是 [1, 2, ..., A.length] 的排列"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nvar pancakeSort = function(A) {\n    \n};"
}, {
    "questionId": "528",
    "titleSlug": "random-pick-with-weight",
    "translatedTitle": "按权重随机选择",
    "translatedContent": [
        "给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i] 成正比。",
        "",
        "说明:",
        "",
        "1 <= w.length <= 10000",
        "1 <= w[i] <= 10^5",
        "pickIndex 将被调用不超过 10000 次",
        "",
        "示例1:",
        "输入: ",
        "[\"Solution\",\"pickIndex\"]",
        "[[[1]],[]]",
        "输出: [null,0]",
        "",
        "示例2:",
        "输入: ",
        "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]",
        "[[[1,3]],[],[],[],[],[]]",
        "输出: [null,0,1,1,1,0]",
        "",
        "输入语法说明: ",
        "",
        "输入是两个列表: 调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\n * @param {number[]} w\n */\nvar Solution = function(w) {\n    \n};\n\n/**\n * @return {number}\n */\nSolution.prototype.pickIndex = function() {\n    \n};\n\n/** \n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */"
}, {
    "questionId": "784",
    "titleSlug": "letter-case-permutation",
    "translatedTitle": "字母大小写全排列",
    "translatedContent": [
        "给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。",
        "",
        "示例:",
        "输入: S = \"a1b2\"",
        "输出: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]",
        "",
        "输入: S = \"3z4\"",
        "输出: [\"3z4\", \"3Z4\"]",
        "",
        "输入: S = \"12345\"",
        "输出: [\"12345\"]",
        "",
        "注意: ",
        "",
        "S 的长度不超过12。",
        "S 仅由数字和字母组成。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {string} S\n * @return {string[]}\n */\nvar letterCasePermutation = function(S) {\n    \n};"
}, {
    "questionId": "590",
    "titleSlug": "n-ary-tree-postorder-traversal",
    "translatedTitle": "N叉树的后序遍历",
    "translatedContent": [
        "给定一个 N 叉树，返回其节点值的后序遍历。",
        "",
        "例如，给定一个 3叉树 :",
        "",
        "返回其后序遍历: [5,6,3,2,4,1].",
        "",
        "说明: 递归法很简单，你可以使用迭代法完成此题吗?"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number[]}\n */\nvar postorder = function(root) {\n    \n};"
}, {
    "questionId": "559",
    "titleSlug": "maximum-depth-of-n-ary-tree",
    "translatedTitle": "N叉树的最大深度",
    "translatedContent": [
        "给定一个 N 叉树，找到其最大深度。",
        "",
        "最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。",
        "",
        "例如，给定一个 3叉树 :",
        "",
        "我们应返回其最大深度，3。",
        "",
        "说明:",
        "",
        "树的深度不会超过 1000。",
        "树的节点总不会超过 5000。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    \n};"
}, {
    "questionId": "427",
    "titleSlug": "construct-quad-tree",
    "translatedTitle": "建立四叉树",
    "translatedContent": [
        "我们想要使用一棵四叉树来储存一个 N x N 的布尔值网络。网络中每一格的值只会是真或假。树的根结点代表整个网络。对于每个结点, 它将被分等成四个孩子结点直到这个区域内的值都是相同的.",
        "",
        "每个结点还有另外两个布尔变量: isLeaf 和 val。isLeaf 当这个节点是一个叶子结点时为真。val 变量储存叶子结点所代表的区域的值。",
        "",
        "你的任务是使用一个四叉树表示给定的网络。下面的例子将有助于你理解这个问题: ",
        "",
        "给定下面这个8 x 8 网络，我们将这样建立一个对应的四叉树: ",
        "",
        "由上文的定义，它能被这样分割: ",
        "",
        "对应的四叉树应该像下面这样，每个结点由一对 (isLeaf, val) 所代表.",
        "",
        "对于非叶子结点，val 可以是任意的，所以使用 * 代替。",
        "",
        "提示: ",
        "N 将小于 1000 且确保是 2 的整次幂。",
        "如果你想了解更多关于四叉树的知识，你可以参考这个 wiki 页面。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * // Definition for a QuadTree node.\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\n *    this.val = val;\n *    this.isLeaf = isLeaf;\n *    this.topLeft = topLeft;\n *    this.topRight = topRight;\n *    this.bottomLeft = bottomLeft;\n *    this.bottomRight = bottomRight;\n * };\n */\n/**\n * @param {number[][]} grid\n * @return {Node}\n */\nvar construct = function(grid) {\n    \n};"
}, {
    "questionId": "757",
    "titleSlug": "set-intersection-size-at-least-two",
    "translatedTitle": " 设置交集大小至少为2",
    "translatedContent": [
        "一个整数区间 [a, b]  ( a < b ) 代表着从 a 到 b 的所有连续整数，包括 a 和 b。",
        "",
        "给你一组整数区间intervals，请找到一个最小的集合 S，使得 S 里的元素与区间intervals中的每一个整数区间都至少有2个元素相交。",
        "",
        "输出这个最小集合S的大小。",
        "",
        "示例 1:",
        "输入: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]",
        "输出: 3",
        "解释:",
        "考虑集合 S = {2, 3, 4}. S与intervals中的四个区间都有至少2个相交的元素。",
        "且这是S最小的情况，故我们输出3。",
        "",
        "示例 2:",
        "输入: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]",
        "输出: 5",
        "解释:",
        "最小的集合S = {1, 2, 3, 4, 5}.",
        "",
        "注意:",
        "",
        "intervals 的长度范围为[1, 3000]。",
        "intervals[i] 长度为 2，分别代表左、右边界。",
        "intervals[i][j] 的值是 [0, 10^8]范围内的整数。"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar intersectionSizeTwo = function(intervals) {\n    \n};"
}, {
    "questionId": "754",
    "titleSlug": "reach-a-number",
    "translatedTitle": "到达终点数字",
    "translatedContent": [
        "在一根无限长的数轴上，你站在0的位置。终点在target的位置。",
        "",
        "每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。",
        "",
        "返回到达终点需要的最小移动次数。",
        "",
        "示例 1:",
        "输入: target = 3",
        "输出: 2",
        "解释:",
        "第一次移动，从 0 到 1 。",
        "第二次移动，从 1 到 3 。",
        "",
        "示例 2:",
        "输入: target = 2",
        "输出: 3",
        "解释:",
        "第一次移动，从 0 到 1 。",
        "第二次移动，从 1 到 -1 。",
        "第三次移动，从 -1 到 2 。",
        "",
        "注意:",
        "",
        "target是在[-10^9, 10^9]范围中的非零整数。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {number} target\n * @return {number}\n */\nvar reachNumber = function(target) {\n    \n};"
}, {
    "questionId": "749",
    "titleSlug": "contain-virus",
    "translatedTitle": "隔离病毒",
    "translatedContent": [
        "病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。",
        "",
        "假设世界由二维矩阵组成，0 表示该区域未感染病毒，而 1 表示该区域已感染病毒。可以在任意 2 个四方向相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。",
        "",
        "每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且保证唯一。",
        "",
        "你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。",
        "",
        "示例 1: ",
        "输入: grid = ",
        "[[0,1,0,0,0,0,0,1],",
        " [0,1,0,0,0,0,0,1],",
        " [0,0,0,0,0,0,0,1],",
        " [0,0,0,0,0,0,0,0]]",
        "输出: 10",
        "说明:",
        "一共有两块被病毒感染的区域: 从左往右第一块需要 5 个防火墙，同时若该区域不隔离，晚上将感染 5 个未感染区域（即被威胁的未感染区域个数为 5）;",
        "第二块需要 4 个防火墙，同理被威胁的未感染区域个数是 4。因此，第一天先隔离左边的感染区域，经过一晚后，病毒传播后世界如下:",
        "[[0,1,0,0,0,0,1,1],",
        " [0,1,0,0,0,0,1,1],",
        " [0,0,0,0,0,0,1,1],",
        " [0,0,0,0,0,0,0,1]]",
        "第二题，只剩下一块未隔离的被感染的连续区域，此时需要安装 5 个防火墙，且安装完毕后病毒隔离任务完成。",
        "",
        "示例 2: ",
        "输入: grid = ",
        "[[1,1,1],",
        " [1,0,1],",
        " [1,1,1]]",
        "输出: 4",
        "说明: ",
        "此时只需要安装 4 面防火墙，就有一小区域可以幸存，不被病毒感染。",
        "注意不需要在世界边界建立防火墙。",
        "",
        "示例 3:",
        "输入: grid = ",
        "[[1,1,1,0,0,0,0,0,0],",
        " [1,0,1,0,1,1,1,1,1],",
        " [1,1,1,0,0,0,0,0,0]]",
        "输出: 13",
        "说明: ",
        "在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙了。",
        "",
        "说明:",
        "",
        "grid 的行数和列数范围是 [1, 50]。",
        " grid[i][j] 只包含 0 或 1 。",
        "题目保证每次选取感染区域进行隔离时，一定存在唯一一个对未感染区域的威胁最大的区域。"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar containVirus = function(grid) {\n    \n};"
}, {
    "questionId": "709",
    "titleSlug": "to-lower-case",
    "translatedTitle": "转换成小写字母",
    "translatedContent": [
        "实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。",
        "",
        "示例 1: ",
        "输入: \"Hello\"",
        "输出: \"hello\"",
        "",
        "示例 2: ",
        "输入: \"here\"",
        "输出: \"here\"",
        "",
        "示例 3: ",
        "输入: \"LOVELY\"",
        "输出: \"lovely\""
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\n * @param {string} str\n * @return {string}\n */\nvar toLowerCase = function(str) {\n    \n};"
}];
module.exports = data;