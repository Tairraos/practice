let data = [{
    "questionId": "1028",
    "titleSlug": "recover-a-tree-from-preorder-traversal",
    "translatedTitle": "从先序遍历还原二叉树",
    "translatedContent": [
        "我们从二叉树的根节点 root 开始进行深度优先搜索。",
        "",
        "在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。",
        "",
        "如果节点只有一个子节点，那么保证该子节点为左子节点。",
        "",
        "给出遍历输出 S，还原树并返回其根节点 root。",
        "",
        "示例 1：",
        "输入：\"1-2--3--4-5--6--7\"",
        "输出：[1,2,5,3,4,6,7]",
        "",
        "示例 2：",
        "输入：\"1-2--3---4-5--6---7\"",
        "输出：[1,2,5,3,null,6,null,4,null,7]",
        "",
        "示例 3：",
        "输入：\"1-401--349---90--88\"",
        "输出：[1,401,null,349,88,90]",
        "",
        "提示：",
        "原始树中的节点数介于 1 和 1000 之间。",
        "每个节点的值介于 1 和 10 ^ 9 之间。"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {string} S\r\n * @return {TreeNode}\r\n */\r\nvar recoverFromPreorder = function(S) {\r\n    \r\n};"
}, {
    "questionId": "1026",
    "titleSlug": "maximum-difference-between-node-and-ancestor",
    "translatedTitle": "节点与其祖先之间的最大差值",
    "translatedContent": [
        "给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。",
        "",
        "（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）",
        "",
        "示例：",
        "输入：[8,3,10,1,6,null,14,null,null,4,7,13]",
        "输出：7",
        "解释： ",
        "我们有大量的节点与其祖先的差值，其中一些如下：",
        "|8 - 3| = 5",
        "|3 - 7| = 4",
        "|8 - 1| = 7",
        "|10 - 13| = 3",
        "在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。",
        "",
        "提示：",
        "树中的节点数在 2 到 5000 之间。",
        "每个节点的值介于 0 到 100000 之间。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxAncestorDiff = function(root) {\r\n    \r\n};"
}, {
    "questionId": "1027",
    "titleSlug": "longest-arithmetic-sequence",
    "translatedTitle": "最长等差数列",
    "translatedContent": [
        "给定一个整数数组 A，返回 A 中最长等差子序列的长度。",
        "",
        "回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。",
        "",
        "示例 1：",
        "输入：[3,6,9,12]",
        "输出：4",
        "解释： ",
        "整个数组是公差为 3 的等差数列。",
        "",
        "示例 2：",
        "输入：[9,4,7,2,10]",
        "输出：3",
        "解释：",
        "最长的等差子序列是 [4,7,10]。",
        "",
        "示例 3：",
        "输入：[20,1,15,3,10,5,8]",
        "输出：4",
        "解释：",
        "最长的等差子序列是 [20,15,10,5]。",
        "",
        "提示：",
        "2 <= A.length <= 2000",
        "0 <= A[i] <= 10000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {number}\r\n */\r\nvar longestArithSeqLength = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1025",
    "titleSlug": "divisor-game",
    "translatedTitle": "除数博弈",
    "translatedContent": [
        "爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。",
        "",
        "最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：",
        "",
        "选出任一 x，满足 0 < x < N 且 N % x == 0 。",
        "用 N - x 替换黑板上的数字 N 。",
        "",
        "如果玩家无法执行这些操作，就会输掉游戏。",
        "",
        "只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。",
        "",
        "示例 1：",
        "输入：2",
        "输出：true",
        "解释：爱丽丝选择 1，鲍勃无法进行操作。",
        "",
        "示例 2：",
        "输入：3",
        "输出：false",
        "解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。",
        "",
        "提示：",
        "1 <= N <= 1000"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {boolean}\r\n */\r\nvar divisorGame = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1024",
    "titleSlug": "video-stitching",
    "translatedTitle": "视频拼接",
    "translatedContent": [
        "你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。",
        "",
        "视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。",
        "",
        "我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。",
        "",
        "示例 1：",
        "输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10",
        "输出：3",
        "解释：",
        "我们选中 [0,2], [8,10], [1,9] 这三个片段。",
        "然后，按下面的方案重制比赛片段：",
        "将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。",
        "现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。",
        "",
        "示例 2：",
        "输入：clips = [[0,1],[1,2]], T = 5",
        "输出：-1",
        "解释：",
        "我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。",
        "",
        "示例 3：",
        "输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9",
        "输出：3",
        "解释： ",
        "我们选取片段 [0,4], [4,7] 和 [6,9] 。",
        "",
        "示例 4：",
        "输入：clips = [[0,4],[2,8]], T = 5",
        "输出：2",
        "解释：",
        "注意，你可能录制超过比赛结束时间的视频。",
        "",
        "提示：",
        "1 <= clips.length <= 100",
        "0 <= clips[i][0], clips[i][1] <= 100",
        "0 <= T <= 100"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[][]} clips\r\n * @param {number} T\r\n * @return {number}\r\n */\r\nvar videoStitching = function(clips, T) {\r\n    \r\n};"
}, {
    "questionId": "1023",
    "titleSlug": "camelcase-matching",
    "translatedTitle": "驼峰式匹配",
    "translatedContent": [
        "如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）",
        "",
        "给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。",
        "",
        "示例 1：",
        "输入：queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"",
        "输出：[true,false,true,true,false]",
        "示例：",
        "\"FooBar\" 可以这样生成：\"F\" + \"oo\" + \"B\" + \"ar\"。",
        "\"FootBall\" 可以这样生成：\"F\" + \"oot\" + \"B\" + \"all\".",
        "\"FrameBuffer\" 可以这样生成：\"F\" + \"rame\" + \"B\" + \"uffer\".",
        "",
        "示例 2：",
        "输入：queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"",
        "输出：[true,false,true,false,false]",
        "解释：",
        "\"FooBar\" 可以这样生成：\"Fo\" + \"o\" + \"Ba\" + \"r\".",
        "\"FootBall\" 可以这样生成：\"Fo\" + \"ot\" + \"Ba\" + \"ll\".",
        "",
        "示例 3：",
        "输出：queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"",
        "输入：[false,true,false,false,false]",
        "解释： ",
        "\"FooBarTest\" 可以这样生成：\"Fo\" + \"o\" + \"Ba\" + \"r\" + \"T\" + \"est\".",
        "",
        "提示：",
        "1 <= queries.length <= 100",
        "1 <= queries[i].length <= 100",
        "1 <= pattern.length <= 100",
        "所有字符串都仅由大写和小写英文字母组成。"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {string[]} queries\r\n * @param {string} pattern\r\n * @return {boolean[]}\r\n */\r\nvar camelMatch = function(queries, pattern) {\r\n    \r\n};"
}, {
    "questionId": "1022",
    "titleSlug": "sum-of-root-to-leaf-binary-numbers",
    "translatedTitle": "从根到叶的二进制数之和",
    "translatedContent": [
        "给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。",
        "",
        "对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。",
        "",
        "以 10^9 + 7 为模，返回这些数字之和。",
        "",
        "示例：",
        "输入：[1,0,1,0,1,0,1]",
        "输出：22",
        "解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22",
        "",
        "提示：",
        "树中的结点数介于 1 和 1000 之间。",
        "node.val 为 0 或 1 。"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumRootToLeaf = function(root) {\r\n    \r\n};"
}, {
    "questionId": "1021",
    "titleSlug": "remove-outermost-parentheses",
    "translatedTitle": "删除最外层的括号",
    "translatedContent": [
        "有效括号字符串为空 (\"\")、\"(\" + A + \")\" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，\"\"，\"()\"，\"(())()\" 和 \"(()(()))\" 都是有效的括号字符串。",
        "",
        "如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。",
        "",
        "给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。",
        "",
        "对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。",
        "",
        "示例 1：",
        "输入：\"(()())(())\"",
        "输出：\"()()()\"",
        "解释：",
        "输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"，",
        "删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。",
        "",
        "示例 2：",
        "输入：\"(()())(())(()(()))\"",
        "输出：\"()()()()(())\"",
        "解释：",
        "输入字符串为 \"(()())(())(()(()))\"，原语化分解得到 \"(()())\" + \"(())\" + \"(()(()))\"，",
        "删除每隔部分中的最外层括号后得到 \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\"。",
        "",
        "示例 3：",
        "输入：\"()()\"",
        "输出：\"\"",
        "解释：",
        "输入字符串为 \"()()\"，原语化分解得到 \"()\" + \"()\"，",
        "删除每个部分中的最外层括号后得到 \"\" + \"\" = \"\"。",
        "",
        "提示：",
        "S.length <= 10000",
        "S[i] 为 \"(\" 或 \")\"",
        "S 是一个有效括号字符串"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {string} S\r\n * @return {string}\r\n */\r\nvar removeOuterParentheses = function(S) {\r\n    \r\n};"
}, {
    "questionId": "1020",
    "titleSlug": "number-of-enclaves",
    "translatedTitle": "飞地的数量",
    "translatedContent": [
        "给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。",
        "",
        "移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。",
        "",
        "返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。",
        "",
        "示例 1：",
        "输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]",
        "输出：3",
        "解释： ",
        "有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。",
        "",
        "示例 2：",
        "输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]",
        "输出：0",
        "解释：",
        "所有 1 都在边界上或可以到达边界。",
        "",
        "提示：",
        "1 <= A.length <= 500",
        "1 <= A[i].length <= 500",
        "0 <= A[i][j] <= 1",
        "所有行的大小都相同"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[][]} A\r\n * @return {number}\r\n */\r\nvar numEnclaves = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1019",
    "titleSlug": "next-greater-node-in-linked-list",
    "translatedTitle": "链表中的下一个更大节点",
    "translatedContent": [
        "给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。",
        "",
        "每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。",
        "",
        "返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。",
        "",
        "注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。",
        "",
        "示例 1：",
        "输入：[2,1,5]",
        "输出：[5,5,0]",
        "",
        "示例 2：",
        "输入：[2,7,4,3,5]",
        "输出：[7,0,5,5,0]",
        "",
        "示例 3：",
        "输入：[1,7,5,1,9,2,5,1]",
        "输出：[7,9,9,9,0,5,0,0]",
        "",
        "提示：",
        "对于链表中的每个节点，1 <= node.val <= 10^9",
        "给定列表的长度在 [0, 10000] 范围内"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {number[]}\r\n */\r\nvar nextLargerNodes = function(head) {\r\n    \r\n};"
}, {
    "questionId": "1018",
    "titleSlug": "binary-prefix-divisible-by-5",
    "translatedTitle": "可被 5 整除的二进制前缀",
    "translatedContent": [
        "给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。",
        "",
        "返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。",
        "",
        "示例 1：",
        "输入：[0,1,1]",
        "输出：[true,false,false]",
        "解释：",
        "输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。",
        "",
        "示例 2：",
        "输入：[1,1,1]",
        "输出：[false,false,false]",
        "",
        "示例 3：",
        "输入：[0,1,1,1,1,1]",
        "输出：[true,false,false,false,true,false]",
        "",
        "示例 4：",
        "输入：[1,1,1,0,1]",
        "输出：[false,false,false,false,false]",
        "",
        "提示：",
        "1 <= A.length <= 30000",
        "A[i] 为 0 或 1"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {boolean[]}\r\n */\r\nvar prefixesDivBy5 = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1017",
    "titleSlug": "convert-to-base-2",
    "translatedTitle": "负二进制转换",
    "translatedContent": [
        "给出数字 N，返回由若干 \"0\" 和 \"1\"组成的字符串，该字符串为 N 的负二进制（base -2）表示。",
        "",
        "除非字符串就是 \"0\"，否则返回的字符串中不能含有前导零。",
        "",
        "示例 1：",
        "输入：2",
        "输出：\"110\"",
        "解释：(-2) ^ 2 + (-2) ^ 1 = 2",
        "",
        "示例 2：",
        "输入：3",
        "输出：\"111\"",
        "解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3",
        "",
        "示例 3：",
        "输入：4",
        "输出：\"100\"",
        "解释：(-2) ^ 2 = 4",
        "",
        "提示：",
        "0 <= N <= 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {string}\r\n */\r\nvar baseNeg2 = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1016",
    "titleSlug": "binary-string-with-substrings-representing-1-to-n",
    "translatedTitle": "子串能表示从 1 到 N 数字的二进制串",
    "translatedContent": [
        "给定一个二进制字符串 S（一个仅由若干 &#39;0&#39; 和 &#39;1&#39; 构成的字符串）和一个正整数 N，如果对于从 1 到 N 的每个整数 X，其二进制表示都是 S 的子串，就返回 true，否则返回 false。",
        "",
        "示例 1：",
        "输入：S = \"0110\", N = 3",
        "输出：true",
        "",
        "示例 2：",
        "输入：S = \"0110\", N = 4",
        "输出：false",
        "",
        "提示：",
        "1 <= S.length <= 1000",
        "1 <= N <= 10^9"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {string} S\r\n * @param {number} N\r\n * @return {boolean}\r\n */\r\nvar queryString = function(S, N) {\r\n    \r\n};"
}, {
    "questionId": "1015",
    "titleSlug": "smallest-integer-divisible-by-k",
    "translatedTitle": "可被 K 整除的最小整数",
    "translatedContent": [
        "给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。",
        "",
        "返回 N 的长度。如果不存在这样的 N，就返回 -1。",
        "",
        "示例 1：",
        "输入：1",
        "输出：1",
        "解释：最小的答案是 N = 1，其长度为 1。",
        "",
        "示例 2：",
        "输入：2",
        "输出：-1",
        "解释：不存在可被 2 整除的正整数 N 。",
        "",
        "示例 3：",
        "输入：3",
        "输出：3",
        "解释：最小的答案是 N = 111，其长度为 3。",
        "",
        "提示：",
        "1 <= K <= 10^5"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number} K\r\n * @return {number}\r\n */\r\nvar smallestRepunitDivByK = function(K) {\r\n    \r\n};"
}, {
    "questionId": "1014",
    "titleSlug": "best-sightseeing-pair",
    "translatedTitle": "最佳观光组合",
    "translatedContent": [
        "给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。",
        "",
        "一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。",
        "",
        "返回一对观光景点能取得的最高分。",
        "",
        "示例：",
        "输入：[8,1,5,2,6]",
        "输出：11",
        "解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11",
        "",
        "提示：",
        "2 <= A.length <= 50000",
        "1 <= A[i] <= 1000"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {number}\r\n */\r\nvar maxScoreSightseeingPair = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1013",
    "titleSlug": "partition-array-into-three-parts-with-equal-sum",
    "translatedTitle": "将数组分成和相等的三个部分",
    "translatedContent": [
        "给定一个整数数组 A，只有我们可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。",
        "",
        "形式上，如果我们可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。",
        "",
        "示例 1：",
        "输出：[0,2,1,-6,6,-7,9,1,2,0,1]",
        "输出：true",
        "解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
        "",
        "示例 2：",
        "输入：[0,2,1,-6,6,7,9,-1,2,0,1]",
        "输出：false",
        "",
        "示例 3：",
        "输入：[3,3,6,5,-2,2,5,1,-9,4]",
        "输出：true",
        "解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4",
        "",
        "提示：",
        "3 <= A.length <= 50000",
        "-10000 <= A[i] <= 10000"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number[]} A\r\n * @return {boolean}\r\n */\r\nvar canThreePartsEqualSum = function(A) {\r\n    \r\n};"
}, {
    "questionId": "1012",
    "titleSlug": "numbers-with-repeated-digits",
    "translatedTitle": "至少有 1 位重复的数字",
    "translatedContent": [
        "给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数。",
        "",
        "示例 1：",
        "输入：20",
        "输出：1",
        "解释：具有至少 1 位重复数字的正数（<= 20）只有 11 。",
        "",
        "示例 2：",
        "输入：100",
        "输出：10",
        "解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。",
        "",
        "示例 3：",
        "输入：1000",
        "输出：262",
        "",
        "提示：",
        "1 <= N <= 10^9"
    ],
    "difficulty": "困难",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {number}\r\n */\r\nvar numDupDigitsAtMostN = function(N) {\r\n    \r\n};"
}, {
    "questionId": "1011",
    "titleSlug": "capacity-to-ship-packages-within-d-days",
    "translatedTitle": "在 D 天内送达包裹的能力",
    "translatedContent": [
        "传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。",
        "",
        "传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。",
        "",
        "返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。",
        "",
        "示例 1：",
        "输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5",
        "输出：15",
        "解释：",
        "船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：",
        "第 1 天：1, 2, 3, 4, 5",
        "第 2 天：6, 7",
        "第 3 天：8",
        "第 4 天：9",
        "第 5 天：10",
        "",
        "请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 ",
        "",
        "示例 2：",
        "输入：weights = [3,2,2,4,1,4], D = 3",
        "输出：6",
        "解释：",
        "船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：",
        "第 1 天：3, 2",
        "第 2 天：2, 4",
        "第 3 天：1, 4",
        "",
        "示例 3：",
        "输入：weights = [1,2,3,1,1], D = 4",
        "输出：3",
        "解释：",
        "第 1 天：1",
        "第 2 天：2",
        "第 3 天：3",
        "第 4 天：1, 1",
        "",
        "提示：",
        "1 <= D <= weights.length <= 50000",
        "1 <= weights[i] <= 500"
    ],
    "difficulty": "中等",
    "codeSnippets": "/**\r\n * @param {number[]} weights\r\n * @param {number} D\r\n * @return {number}\r\n */\r\nvar shipWithinDays = function(weights, D) {\r\n    \r\n};"
}, {
    "questionId": "1010",
    "titleSlug": "pairs-of-songs-with-total-durations-divisible-by-60",
    "translatedTitle": "总持续时间可被 60 整除的歌曲",
    "translatedContent": [
        "在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。",
        "",
        "返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。",
        "",
        "示例 1：",
        "输入：[30,20,150,100,40]",
        "输出：3",
        "解释：这三对的总持续时间可被 60 整数：",
        "(time[0] = 30, time[2] = 150): 总持续时间 180",
        "(time[1] = 20, time[3] = 100): 总持续时间 120",
        "(time[1] = 20, time[4] = 40): 总持续时间 60",
        "",
        "示例 2：",
        "输入：[60,60,60]",
        "输出：3",
        "解释：所有三对的总持续时间都是 120，可以被 60 整数。",
        "",
        "提示：",
        "1 <= time.length <= 60000",
        "1 <= time[i] <= 500"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number[]} time\r\n * @return {number}\r\n */\r\nvar numPairsDivisibleBy60 = function(time) {\r\n    \r\n};"
}, {
    "questionId": "1009",
    "titleSlug": "complement-of-base-10-integer",
    "translatedTitle": "十进制整数的反码",
    "translatedContent": [
        "每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 \"101\"，11 可以用二进制 \"1011\" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。",
        "",
        "二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 \"101\" 的二进制反码为 \"010\"。",
        "",
        "给定十进制数 N，返回其二进制表示的反码所对应的十进制整数。",
        "",
        "示例 1：",
        "输入：5",
        "输出：2",
        "解释：5 的二进制表示为 \"101\"，其二进制反码为 \"010\"，也就是十进制中的 2 。",
        "",
        "示例 2：",
        "输入：7",
        "输出：0",
        "解释：7 的二进制表示为 \"111\"，其二进制反码为 \"000\"，也就是十进制中的 0 。",
        "",
        "示例 3：",
        "输入：10",
        "输出：5",
        "解释：10 的二进制表示为 \"1010\"，其二进制反码为 \"0101\"，也就是十进制中的 5 。",
        "",
        "提示：",
        "0 <= N < 10^9"
    ],
    "difficulty": "容易",
    "codeSnippets": "/**\r\n * @param {number} N\r\n * @return {number}\r\n */\r\nvar bitwiseComplement = function(N) {\r\n    \r\n};"
}];
module.exports = data;